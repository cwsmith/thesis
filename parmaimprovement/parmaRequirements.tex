The dynamic partitioning problem seeks to quickly improve the load balance and
reduce communication costs of an existing partition that is reasonably
distributed; such as those generated by (hyper)graph and geometric
partitioning tools.
Hendrickson and Devine~\cite{hendrickson2000dynamic}
define the requirements of dynamic partitioning as: (1) balance the
computational work, (2) reduce the inter-processor communication costs, (3)
modify the partition incrementally, (4) output the new communication pattern,
(5) execute on parallel systems quickly, (6) consume small amounts of memory,
and (7) provide an easy to use functional interface.
For unstructured meshes these requirements are mostly satisfied by multi-level
(hyper)graph and recursive sectioning methods~\cite{graphPtnSourcebookParComp}.
Multi-level (hyper)graph are limited in scalability; memory requirements
limit their effective usage on more than several thousand processors
~\cite{harlacherMortonSFCvsParmetis2012}.
Recursive sectioning methods are limited in quality; they have lower memory and
time requirements at the expense of increased inter-part surface area.
Additionally, these methods can only balance one dimension of mesh entity.
This approach can result in a less-than optimal balance of the other entity
dimensions as process counts increase.
The balance of the other dimensions can be improved, but not fixed, with carefully
defined weights in the multi-constraint partitioning options provided by
Zoltan's recursive coordinate bisection implementation and by the multi-level
(hyper)graph
methods~\cite{aykanat2008multi,karypis1998multilevel,schloegel2002parallel}.

In this work, ParMA, combined with graph and geometric partitioning methods
provided by Zoltan~\cite{devine2002zoltan}, satisfies the
requirements for dynamic load balancing to over one million parts on meshes
with over 12 billion tetrahedral elements.
Partition quality requirements 1 and 2 are satisfied by partitioning the
mesh with a graph or geometric partitioner and then running ParMA to
reduce the imbalance of mesh entity dimensions critical to the application.
For example, ParMA is applied to balance the entities used as degree of
freedom holders in finite element method procedures.
The incremental partition change requirement (3) is implicitly satisfied by the
definition of ParMA's diffusion procedure and recursive coordinate bisection.
Graph-based methods provided by Zoltan's API also have execution modes that
minimize data movement.
Requirement 4 is implicitly satisfied as applications in the workflow are
driven from the partitioning of the mesh that ParMA produces.
Performance requirements 5 and 6 are satisfied by combining ParMA with a
partitioner that scales to the required concurrency level.
Lastly, requirement 7 is satisfied through Zoltan's API to interact with
the mesh data structure and ParMA's direct use of mesh modification and query
APIs.
